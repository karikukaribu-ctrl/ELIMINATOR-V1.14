<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>ELIMINATOR</title>
  <style>
    :root{
      --bg:#0f1115;
      --fg:#e9edf5;
      --muted:#a8b0bd;

      --panelA: rgba(14,16,24,0.62);
      --panelB: rgba(10,11,18,0.72);

      --glass: rgba(12,14,22,0.34);
      --glass2: rgba(12,14,22,0.44);

      --shadow: 0 18px 60px rgba(0,0,0,0.58);
      --r: 22px;

      /* GREEN FX */
      --green: #38ff9a;
      --green2:#14c86f;
      --greenGlow: 0 0 10px rgba(56,255,154,0.35), 0 0 28px rgba(20,200,111,0.20);
      --greenGlowStrong: 0 0 12px rgba(56,255,154,0.55), 0 0 44px rgba(20,200,111,0.26);

      --accent1:#f2f2f2;
      --accent2:#aeb7c7;

      --orange:#ff9a38;
      --orangeGlow: 0 0 10px rgba(255,154,56,0.28), 0 0 28px rgba(255,154,56,0.16);
    }

    /* Light mode overrides */
    body.light{
      --bg:#f6f7fb;
      --fg:#11131a;
      --muted:#4c5566;

      --panelA: rgba(255,255,255,0.72);
      --panelB: rgba(255,255,255,0.82);

      --glass: rgba(255,255,255,0.65);
      --glass2: rgba(255,255,255,0.78);

      --shadow: 0 18px 60px rgba(0,0,0,0.16);

      --accent1:#10131a;
      --accent2:#3b4352;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(1200px 600px at 50% 0%, rgba(255,255,255,0.04), transparent 70%), var(--bg);
      color: var(--fg);
      overflow-x:hidden;
    }

    .shell{
      min-height:100vh;
      display:flex;
      flex-direction:column;
      gap: 6px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      gap:10px;
      position:sticky;
      top:0;
      z-index: 40;
      background: linear-gradient(180deg, rgba(15,17,21,0.86), rgba(15,17,21,0.00));
      -webkit-backdrop-filter: blur(10px) saturate(140%);
      backdrop-filter: blur(10px) saturate(140%);
    }
    body.light .topbar{
      background: linear-gradient(180deg, rgba(246,247,251,0.90), rgba(246,247,251,0.00));
    }
    .topbar .left, .topbar .right{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .iconbtn, .btn, .tab{
      border: none;
      background: var(--glass);
      color: var(--fg);
      border-radius: 14px;
      padding: 10px 12px;
      cursor:pointer;
      font-weight: 950;
      letter-spacing:0.08em;
      text-transform: uppercase;
      font-size: 12px;
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      backdrop-filter: blur(14px) saturate(140%);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      transition: transform 120ms ease, background 120ms ease, box-shadow 120ms ease, color 120ms ease;
    }
    .iconbtn:hover, .btn:hover, .tab:hover{ background: var(--glass2); }
    .iconbtn:active, .btn:active, .tab:active{ transform: translateY(1px); }
    .iconbtn:disabled, .btn:disabled{ opacity:0.5; cursor:not-allowed; }

    .topFx{
      color: rgba(56,255,154,0.90);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35), var(--greenGlow);
    }
    .topFx:hover{
      color: rgba(56,255,154,1);
      box-shadow: 0 12px 34px rgba(0,0,0,0.45), var(--greenGlowStrong);
      background: rgba(12,18,18,0.36);
    }
    .topFx:active{
      box-shadow: 0 10px 30px rgba(0,0,0,0.35), var(--greenGlow);
    }

    .chips{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .chip{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding:7px 10px;
      border-radius: 999px;
      background: rgba(12,14,22,0.34);
      color: rgba(255,255,255,0.72);
      font-size: 12px;
      font-weight: 950;
      user-select:none;
      white-space:nowrap;
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      backdrop-filter: blur(14px) saturate(140%);
      box-shadow: 0 10px 30px rgba(0,0,0,0.28);
    }
    body.light .chip{ background: rgba(0,0,0,0.06); color: rgba(0,0,0,0.68); }
    .chip b{ color: rgba(255,255,255,0.92); font-weight: 1000; }
    body.light .chip b{ color: rgba(0,0,0,0.92); }

    .hero{
      display:grid;
      justify-items:center;
      gap: 6px;
      padding: 2px 12px 0;
      flex: 0 0 auto;
    }
    .hero h1{
      margin:0;
      font-size: clamp(30px, 5.2vw, 56px);
      font-weight: 1000;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      line-height: 1;
      text-align:center;
    }
    .hero p{
      margin:0;
      color: rgba(255,255,255,0.62);
      font-size: 12px;
      letter-spacing:0.14em;
      text-transform: uppercase;
      text-align:center;
    }
    body.light .hero p{ color: rgba(0,0,0,0.55); }

    .floatLine{
      min-height: 18px;
      padding: 0 12px 4px;
      text-align:center;
      color: rgba(255,255,255,0.70);
      font-size: 13px;
      letter-spacing: 0.02em;
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity 220ms ease, transform 220ms ease;
      user-select:none;
      flex: 0 0 auto;
    }
    body.light .floatLine{ color: rgba(0,0,0,0.65); }
    .floatLine.show{ opacity: 1; transform: translateY(0); }

    .stage{
      flex: 1 1 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px 12px 14px;
      min-height: 0;
    }

    .focusCard{
      width: min(920px, 96vw);
      border-radius: var(--r);
      background:
        radial-gradient(900px 420px at 50% 0%, rgba(255,255,255,0.10), transparent 62%),
        linear-gradient(180deg, var(--panelA), var(--panelB));
      box-shadow: var(--shadow);
      padding: 16px;
      display:grid;
      gap: 14px;
      -webkit-backdrop-filter: blur(14px) saturate(130%);
      backdrop-filter: blur(14px) saturate(130%);
    }

    .barWrap{
      border-radius: 999px;
      height: 34px;
      background: rgba(255,255,255,0.08);
      overflow:hidden;
      position:relative;
    }
    body.light .barWrap{ background: rgba(0,0,0,0.08); }

    .barFill{
      height:100%;
      width:100%;
      background: linear-gradient(90deg, var(--accent1), var(--accent2));
      transition: width 220ms ease;
    }
    .barLabel{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 12px;
      font-weight: 1000;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: rgba(10,12,16,0.92);
      mix-blend-mode: screen;
      user-select:none;
      pointer-events:none;
    }
    body.light .barLabel{ mix-blend-mode: normal; color: rgba(0,0,0,0.70); }

    .target{ display:grid; gap: 10px; text-align:center; align-items:center; }
    .targetTitle{
      font-size: clamp(22px, 3.8vw, 34px);
      font-weight: 1000;
      line-height:1.15;
      word-break: break-word;
      padding: 0 6px;
    }
    .targetMeta{
      color: rgba(255,255,255,0.62);
      font-size: 12px;
      letter-spacing:0.04em;
      line-height:1.25;
      padding: 0 6px;
    }
    body.light .targetMeta{ color: rgba(0,0,0,0.58); }

    .sbarWrap{
      border-radius: 999px;
      height: 14px;
      background: rgba(255,255,255,0.08);
      overflow:hidden;
      position:relative;
    }
    body.light .sbarWrap{ background: rgba(0,0,0,0.08); }

    .sbarFill{
      height:100%;
      width:100%;
      background: linear-gradient(90deg, rgba(242,242,242,0.85), rgba(174,183,199,0.70));
      transition: width 180ms ease;
    }
    .sbarLabel{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 11px;
      font-weight: 1000;
      color: rgba(10,12,16,0.90);
      mix-blend-mode: screen;
      user-select:none;
      pointer-events:none;
    }
    body.light .sbarLabel{ mix-blend-mode: normal; color: rgba(0,0,0,0.65); }

    .actions{
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      align-items:center;
      gap: 12px;
      margin-top: 2px;
    }
    .actions .leftA{ display:flex; justify-content:flex-end; }
    .actions .centerA{ display:flex; justify-content:center; }
    .actions .rightA{ display:flex; justify-content:flex-start; }

    .btnRoulette{
      width: 108px;
      height: 108px;
      border-radius: 999px;
      background:
        radial-gradient(closest-side, rgba(255,255,255,0.16), rgba(0,0,0,0.06)),
        linear-gradient(180deg, rgba(12,14,22,0.55), rgba(8,9,14,0.68));
      color: var(--fg);
      cursor:pointer;
      font-weight: 1000;
      letter-spacing:0.10em;
      text-transform: uppercase;
      display:grid;
      place-items:center;
      user-select:none;
      position:relative;
      box-shadow: 0 16px 40px rgba(0,0,0,0.55);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      backdrop-filter: blur(14px) saturate(140%);
      border: none;
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
    }
    body.light .btnRoulette{
      background: linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,255,255,0.70));
      box-shadow: 0 16px 40px rgba(0,0,0,0.16);
      color: rgba(0,0,0,0.85);
    }
    .btnRoulette .ring{
      position:absolute; inset:10px;
      border-radius: 999px;
      border:1px dashed rgba(255,255,255,0.18);
      opacity:0.75;
    }
    body.light .btnRoulette .ring{ border-color: rgba(0,0,0,0.18); }
    .btnRoulette:hover{ background: rgba(12,14,22,0.62); }
    body.light .btnRoulette:hover{ background: rgba(255,255,255,0.90); }
    .btnRoulette:active{ transform: translateY(1px); }
    .btnRoulette.spinning .ring{ animation: spin 650ms linear infinite; }
    @keyframes spin{ from{ transform: rotate(0deg);} to{ transform: rotate(360deg);} }

    .btnBig{
      min-height: 64px;
      padding: 16px 18px;
      border-radius: 18px;
      background:
        radial-gradient(900px 260px at 30% 20%, rgba(255,255,255,0.12), transparent 60%),
        linear-gradient(180deg, rgba(12,14,22,0.52), rgba(8,9,14,0.68));
      font-weight: 1000;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      box-shadow: 0 12px 30px rgba(0,0,0,0.45);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      backdrop-filter: blur(14px) saturate(140%);
      border:none;
      color: var(--fg);
      cursor:pointer;
      white-space:nowrap;
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
    }
    body.light .btnBig{
      background: linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,255,255,0.72));
      box-shadow: 0 12px 30px rgba(0,0,0,0.14);
      color: rgba(0,0,0,0.85);
    }
    .btnBig:hover{ background: rgba(12,14,22,0.62); }
    body.light .btnBig:hover{ background: rgba(255,255,255,0.92); }
    .btnBig:active{ transform: translateY(1px); }

    .subActions{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .btnMiniMenu{
      padding: 12px 12px;
      border-radius: 16px;
    }

    .hint{
      text-align:center;
      color: rgba(255,255,255,0.55);
      font-size: 12px;
      line-height:1.25;
      padding: 4px 12px 12px;
      opacity:0.95;
      flex: 0 0 auto;
    }
    body.light .hint{ color: rgba(0,0,0,0.55); }

    .overlay{
      position:fixed; inset:0;
      background: rgba(0,0,0,0.60);
      opacity:0;
      pointer-events:none;
      transition: opacity 160ms ease;
      z-index: 90;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }

    .drawer{
      position:fixed;
      top:0; left:0;
      height:100vh;
      width: min(640px, 92vw);
      background:
        radial-gradient(900px 420px at 40% 0%, rgba(56,255,154,0.10), transparent 62%),
        radial-gradient(900px 420px at 10% 30%, rgba(255,255,255,0.08), transparent 62%),
        linear-gradient(180deg, rgba(14,16,24,0.78), rgba(9,10,16,0.86));
      transform: translateX(-110%);
      transition: transform 180ms ease;
      z-index: 100;
      display:grid;
      grid-template-rows: auto auto 1fr auto;
      gap: 12px;
      padding: 14px;
      box-shadow: var(--shadow);
      -webkit-backdrop-filter: blur(18px) saturate(140%);
      backdrop-filter: blur(18px) saturate(140%);
    }
    body.light .drawer{
      background: linear-gradient(180deg, rgba(255,255,255,0.92), rgba(255,255,255,0.88));
      box-shadow: 0 18px 60px rgba(0,0,0,0.18);
    }
    .drawer.show{ transform: translateX(0); }

    .drawerHeader{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .drawerHeader .h{
      font-weight: 1000;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(56,255,154,0.70);
      text-shadow: 0 0 16px rgba(56,255,154,0.15);
    }

    .tabs{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .tab.active{
      background: rgba(12,18,18,0.36);
      color: rgba(56,255,154,0.95);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25), var(--greenGlow);
    }

    .drawerBody{
      overflow:auto;
      padding-right: 4px;
      display:grid;
      gap: 12px;
      align-content:start;
    }

    .card{
      border-radius: 18px;
      background: rgba(12,14,22,0.30);
      padding: 12px;
      display:grid;
      gap:10px;
      -webkit-backdrop-filter: blur(16px) saturate(150%);
      backdrop-filter: blur(16px) saturate(150%);
      box-shadow: 0 10px 30px rgba(0,0,0,0.28);
    }
    body.light .card{ background: rgba(0,0,0,0.04); box-shadow: 0 10px 30px rgba(0,0,0,0.10); }

    .cardTitle{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      color: rgba(255,255,255,0.62);
      font-weight: 1000;
      letter-spacing:0.14em;
      text-transform: uppercase;
      font-size: 11px;
    }
    body.light .cardTitle{ color: rgba(0,0,0,0.62); }

    textarea, select, input[type="text"], input[type="number"]{
      font:inherit;
      border:none;
      background: rgba(0,0,0,0.18);
      color: var(--fg);
      border-radius: 14px;
      padding: 10px 12px;
      outline:none;
      font-size:13px;
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      backdrop-filter: blur(14px) saturate(140%);
    }
    body.light textarea, body.light select, body.light input[type="text"], body.light input[type="number"]{
      background: rgba(0,0,0,0.06);
      color: rgba(0,0,0,0.88);
    }
    textarea{ width:100%; min-height: 140px; resize: vertical; line-height:1.35; }

    .rowBtns{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
      align-items:center;
    }

    .list{ display:grid; gap:8px; }

    .trow{
      border-radius: 16px;
      background: rgba(0,0,0,0.14);
      padding: 10px;
      display:grid;
      gap:8px;
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      backdrop-filter: blur(14px) saturate(140%);
    }
    body.light .trow{ background: rgba(0,0,0,0.06); }

    /* Kiffance rows: orange */
    .trow.kiffance{
      box-shadow: var(--orangeGlow);
      border: 1px solid rgba(255,154,56,0.20);
    }
    .trow.kiffance .tname{ color: rgba(255,154,56,0.95); }
    body.light .trow.kiffance .tname{ color: rgba(184,96,18,0.95); }

    .trowTop{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .tname{
      font-weight: 950;
      font-size: 14px;
      line-height:1.2;
      word-break: break-word;
    }
    .tmini{
      color: rgba(255,255,255,0.62);
      font-size: 12px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      line-height:1.15;
    }
    body.light .tmini{ color: rgba(0,0,0,0.60); }

    .tacts{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }
    .done{ text-decoration: line-through; opacity:0.55; }

    .sbarMiniWrap{
      border-radius: 999px;
      height: 12px;
      background: rgba(255,255,255,0.08);
      overflow:hidden;
      position:relative;
    }
    body.light .sbarMiniWrap{ background: rgba(0,0,0,0.08); }

    .sbarMiniFill{
      height:100%;
      background: linear-gradient(90deg, rgba(242,242,242,0.78), rgba(174,183,199,0.62));
      transition: width 180ms ease;
    }

    details{
      border-radius: 18px;
      overflow:hidden;
      background: rgba(12,14,22,0.22);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      backdrop-filter: blur(14px) saturate(140%);
    }
    body.light details{ background: rgba(0,0,0,0.04); }

    summary{
      cursor:pointer;
      padding: 10px 12px;
      color: rgba(255,255,255,0.62);
      font-weight: 1000;
      letter-spacing:0.14em;
      text-transform: uppercase;
      font-size: 11px;
      user-select:none;
      list-style:none;
    }
    body.light summary{ color: rgba(0,0,0,0.62); }

    details > .inside{
      padding: 10px 12px 12px;
      display:grid;
      gap:10px;
    }

    /* Celebration overlay (no image, auto close) */
    .celeOverlay{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.54);
      opacity:0;
      pointer-events:none;
      transition: opacity 180ms ease;
      z-index: 130;
      padding: 14px;
    }
    .celeOverlay.show{ opacity:1; pointer-events:auto; }
    .celeCard{
      width: min(620px, 94vw);
      border-radius: 22px;
      background:
        radial-gradient(900px 420px at 30% 0%, rgba(56,255,154,0.14), transparent 62%),
        linear-gradient(180deg, rgba(14,16,24,0.82), rgba(9,10,16,0.90));
      box-shadow: var(--shadow);
      padding: 14px 14px 16px;
      display:grid;
      gap: 10px;
      -webkit-backdrop-filter: blur(18px) saturate(150%);
      backdrop-filter: blur(18px) saturate(150%);
      text-align:center;
    }
    body.light .celeCard{
      background: linear-gradient(180deg, rgba(255,255,255,0.92), rgba(255,255,255,0.86));
      color: rgba(0,0,0,0.88);
    }
    .celeTitle{
      font-weight: 1000;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: rgba(56,255,154,0.92);
      font-size: 12px;
    }
    body.light .celeTitle{ color: rgba(20,120,70,0.95); }
    .celeMain{
      font-size: 20px;
      font-weight: 1000;
      line-height:1.2;
      letter-spacing: 0.02em;
    }
    .celeSub{
      font-size: 12px;
      opacity:0.78;
      letter-spacing:0.06em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.70);
    }
    body.light .celeSub{ color: rgba(0,0,0,0.58); }

    .toast{
      position:fixed;
      left:50%;
      bottom: 14px;
      transform: translateX(-50%);
      background: rgba(11,13,18,0.74);
      border:none;
      border-radius: 14px;
      padding: 12px 14px;
      color: var(--fg);
      font-size: 13px;
      opacity:0;
      pointer-events:none;
      transition: opacity 160ms ease, transform 160ms ease;
      max-width: min(900px, calc(100vw - 24px));
      box-shadow: var(--shadow);
      white-space:pre-wrap;
      z-index: 120;
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      backdrop-filter: blur(14px) saturate(140%);
    }
    body.light .toast{
      background: rgba(255,255,255,0.80);
      color: rgba(0,0,0,0.82);
      box-shadow: 0 18px 60px rgba(0,0,0,0.16);
    }
    .toast.show{ opacity:1; transform: translateX(-50%) translateY(-6px); }

    canvas#fx{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index: 110;
    }

    @media (max-width: 520px){
      .btnRoulette{ width: 100px; height: 100px; }
      .btnBig{ min-height: 60px; padding: 14px 16px; }
      .actions{ gap: 10px; }
      .focusCard{ padding: 14px; }
      .barWrap{ height: 32px; }
    }
    @media (max-width: 380px){
      .actions{ grid-template-columns: 1fr; }
      .actions .leftA, .actions .centerA, .actions .rightA{ justify-content:center; }
      .btnBig{ width: 92vw; }
    }
  </style>
</head>

<body>
  <canvas id="fx"></canvas>

  <div class="shell">
    <div class="topbar" id="topbar">
      <div class="left">
        <button class="iconbtn topFx" id="btnMenu" aria-label="Menu">Menu</button>
        <button class="iconbtn topFx" id="btnReset">Reset</button>
      </div>

      <div class="right chips" aria-label="Compteurs">
        <span class="chip">Départ <b id="startTasks">0</b></span>
        <span class="chip">Reste <b id="leftTasks">0</b></span>
        <span class="chip">ETHORION <b id="leftEth">0</b>/<b id="startEth">0</b></span>
        <span class="chip">Éliminé <b id="elimEth">0</b></span>
        <span class="chip">Tâches <b id="doneTasks">0</b>/<b id="startTasks2">0</b></span>
      </div>
    </div>

    <header class="hero">
      <h1>ELIMINATOR</h1>
      <p>Dégommez-les tous</p>
    </header>

    <div class="floatLine" id="floatLine"> </div>

    <div class="stage">
      <section class="focusCard" aria-label="Focus">
        <div class="barWrap" aria-label="Progression globale">
          <div class="barFill" id="gFill"></div>
          <div class="barLabel" id="gLabel">100%</div>
        </div>

        <div class="target" aria-label="Cible">
          <div class="targetTitle" id="focusTitle">CIBLE EN COURS DE RECHERCHE</div>
          <div class="targetMeta" id="focusMeta">—</div>

          <div class="chips" style="justify-content:center;">
            <span class="chip">ETHORION <b id="focusEth">0</b></span>
            <span class="chip">P <b id="focusPrio">—</b></span>
            <span class="chip">Énergie <b id="focusEnergy">—</b></span>
            <span class="chip">Mode <b id="focusMode">—</b></span>
          </div>

          <div class="sbarWrap" aria-label="Progression tâche">
            <div class="sbarFill" id="tFill"></div>
            <div class="sbarLabel" id="tLabel">100%</div>
          </div>

          <div class="actions" aria-label="Actions">
            <div class="leftA">
              <button class="btnBig" id="btnSkip" aria-label="Passer">Passer</button>
            </div>

            <div class="centerA">
              <button class="btnRoulette" id="btnRoulette" aria-label="Roulette">
                <span class="ring"></span>
                Roulette
              </button>
            </div>

            <div class="rightA">
              <button class="btnBig" id="btnDego" aria-label="Dégommer">Dégommer 1 ETHORION</button>
            </div>
          </div>

          <div class="subActions">
            <button class="btn topFx btnMiniMenu" id="btnMiniMenu">Menu</button>
            <button class="btn" id="btnNotes">Notes</button>
            <button class="btn" id="btnDone">Terminer</button>
          </div>
        </div>
      </section>
    </div>

    <div class="hint">
      Import : colle n’importe quel texte multi-lignes. Les lignes finissant par “:” sont des catégories. Le reste = tâches.
      Raccourci : Ctrl/⌘+Enter pour ajouter depuis Inbox.
    </div>
  </div>

  <!-- Drawer -->
  <div class="overlay" id="overlay"></div>
  <aside class="drawer" id="drawer" aria-label="Menu latéral">
    <div class="drawerHeader">
      <div class="h">Options</div>
      <button class="btn topFx" id="btnClose">Fermer</button>
    </div>

    <div class="tabs" id="tabs"></div>
    <div class="drawerBody" id="drawerBody"></div>

    <div class="rowBtns">
      <button class="btn topFx" id="btnUndo">Undo</button>
      <button class="btn topFx" id="btnRedo">Redo</button>
    </div>
  </aside>

  <!-- Celebration overlay (simple, no image, auto close) -->
  <div class="celeOverlay" id="celeOverlay" aria-label="Célébration">
    <div class="celeCard">
      <div class="celeTitle" id="celeTitle">Victoire</div>
      <div class="celeMain" id="celeMain">—</div>
      <div class="celeSub" id="celeSub">—</div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  "use strict";

  // =========================
  // Storage + State
  // =========================
  const LS_KEY = "eliminator_app_v5";
  const MAX_HISTORY = 60;

  const el = (id)=>document.getElementById(id);
  const now = ()=>Date.now();
  const clamp = (n,a,b)=>Math.max(a, Math.min(b,n));
  const uid = ()=> Math.random().toString(36).slice(2,10)+"-"+Date.now().toString(36);

  // Counters
  const startTasksEl  = el("startTasks");
  const startTasks2El = el("startTasks2");
  const leftTasksEl   = el("leftTasks");
  const startEthEl    = el("startEth");
  const leftEthEl     = el("leftEth");
  const elimEthEl     = el("elimEth");
  const doneTasksEl   = el("doneTasks");

  // Bars
  const gFill = el("gFill");
  const gLabel = el("gLabel");
  const tFill = el("tFill");
  const tLabel = el("tLabel");

  // Focus
  const focusTitle = el("focusTitle");
  const focusMeta = el("focusMeta");
  const focusEth = el("focusEth");
  const focusPrio = el("focusPrio");
  const focusEnergy = el("focusEnergy");
  const focusMode = el("focusMode");

  // Float line
  const floatLine = el("floatLine");

  // Buttons
  const btnMenu = el("btnMenu");
  const btnMiniMenu = el("btnMiniMenu");
  const btnReset = el("btnReset");
  const btnRoulette = el("btnRoulette");
  const btnDego = el("btnDego");
  const btnNotes = el("btnNotes");
  const btnDone = el("btnDone");
  const btnSkip = el("btnSkip");

  // Drawer
  const overlay = el("overlay");
  const drawer = el("drawer");
  const btnClose = el("btnClose");
  const tabs = el("tabs");
  const drawerBody = el("drawerBody");
  const btnUndo = el("btnUndo");
  const btnRedo = el("btnRedo");

  // Celebration
  const celeOverlay = el("celeOverlay");
  const celeTitle = el("celeTitle");
  const celeMain = el("celeMain");
  const celeSub = el("celeSub");

  // Toast + FX
  const toast = el("toast");
  const fxCanvas = el("fx");
  const fx = fxCanvas.getContext("2d");

  // =========================
  // Day helper
  // =========================
  function isoDay(d = new Date()){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const da = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${da}`;
  }

  // =========================
  // Default State
  // =========================
  function initial(){
    const today = isoDay();
    return {
      version: 5,
      day: { id: today, startTasks: 0, startEth: 0 },
      focusId: null,

      energyProfile: { level: 2, motivation: 2 }, // 1..3

      mode: { pick: "roulette", orderBy: "prio", includeCats: [] },

      ui: { activeTab: "inbox", sort: "order", theme: "dark" },

      // Kiffance engine
      kiffance: {
        enabled: true,
        afterEth: 6,          // after ~6 ethorions of work, allow a kiffance surprise
        chance: 0.55,         // probability when eligible
        lastWorkEth: 0,
        pools: {
          "5":  ["respiration 4-7-8", "étirements", "eau + fenêtre", "mini marche", "yeux: 20-20-20"],
          "10": ["lecture plaisir", "musique", "ranger 10 objets", "écrire 5 lignes", "thé/café conscient"],
          "15": ["sortir dehors", "méditation guidée", "douche rapide", "dessin idiot", "appel sympa"],
          "20": ["balade", "petit repas", "sport doux", "journal + plan", "sieste flash"]
        }
      },

      tasks: [],

      sets: [
        {
          id: "set_u74_adm",
          name: "Unité 74 — Admission (5)",
          lines: [
            "PATIENTS:",
            "Patient 1 — 4 ethorions — importance 3",
            "Patient 2 — 4 ethorions — importance 3",
            "Patient 3 — 4 ethorions — importance 3",
            "Patient 4 — 4 ethorions — importance 3",
            "Patient 5 — 4 ethorions — importance 3",
            "ENCODAGE:",
            "Encoder la note Patient 1 — 2 ethorions — importance 2",
            "Encoder la note Patient 2 — 2 ethorions — importance 2",
            "Encoder la note Patient 3 — 2 ethorions — importance 2",
            "Encoder la note Patient 4 — 2 ethorions — importance 2",
            "Encoder la note Patient 5 — 2 ethorions — importance 2"
          ]
        },
        {
          id: "set_u74_sortie",
          name: "Unité 74 — Sortie (5)",
          lines: [
            "PATIENTS:",
            "Patient 1 — 3 ethorions — importance 3",
            "Patient 2 — 3 ethorions — importance 3",
            "Patient 3 — 3 ethorions — importance 3",
            "Patient 4 — 3 ethorions — importance 3",
            "Patient 5 — 3 ethorions — importance 3",
            "ENCODAGE:",
            "Encoder la note Patient 1 — 2 ethorions — importance 2",
            "Encoder la note Patient 2 — 2 ethorions — importance 2",
            "Encoder la note Patient 3 — 2 ethorions — importance 2",
            "Encoder la note Patient 4 — 2 ethorions — importance 2",
            "Encoder la note Patient 5 — 2 ethorions — importance 2"
          ]
        },
        {
          id: "set_consult_6",
          name: "Consultations (6)",
          lines: [
            "CONSULTATIONS:",
            "Voir patient 1 — 4 ethorions — importance 3",
            "Voir patient 2 — 4 ethorions — importance 3",
            "Voir patient 3 — 4 ethorions — importance 3",
            "Voir patient 4 — 4 ethorions — importance 3",
            "Voir patient 5 — 4 ethorions — importance 3",
            "Voir patient 6 — 4 ethorions — importance 3",
            "NOTES:",
            "Faire la note patient 1 — 3 ethorions — importance 2",
            "Faire la note patient 2 — 3 ethorions — importance 2",
            "Faire la note patient 3 — 3 ethorions — importance 2",
            "Faire la note patient 4 — 3 ethorions — importance 2",
            "Faire la note patient 5 — 3 ethorions — importance 2",
            "Faire la note patient 6 — 3 ethorions — importance 2"
          ]
        },
        {
          id: "set_daily_starter",
          name: "Starter quotidien",
          lines: [
            "ORGANISATION:",
            "Vérifier l’horaire + adapter planning — 6 ethorions — importance 3",
            "Emails rapides — 2 ethorions — importance 2",
            "Appels indispensables — 2 ethorions — importance 2",
            "Un dossier lourd (1) — 10 ethorions — importance 3"
          ]
        }
      ],

      scratch: "",

      history: { undo: [], redo: [] },
      events: []
    };
  }

  let state = load() || initial();

  function save(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }

  function load(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return null;
      const obj = JSON.parse(raw);
      if(!obj || !Array.isArray(obj.tasks)) return null;

      if(!obj.sets) obj.sets = initial().sets;
      if(!obj.history) obj.history = {undo:[], redo:[]};
      if(!obj.events) obj.events = [];
      if(!obj.energyProfile) obj.energyProfile = {level:2, motivation:2};
      if(!obj.mode) obj.mode = {pick:"roulette", orderBy:"prio", includeCats:[]};
      if(!Array.isArray(obj.mode.includeCats)) obj.mode.includeCats = [];
      if(!obj.ui) obj.ui = {activeTab:"inbox", sort:"order", theme:"dark"};
      if(!obj.day) obj.day = initial().day;
      if(typeof obj.scratch !== "string") obj.scratch = "";
      if(!obj.kiffance) obj.kiffance = initial().kiffance;

      applyTheme();
      return obj;
    }catch{ return null; }
  }

  // =========================
  // Theme
  // =========================
  function applyTheme(){
    const th = state.ui?.theme || "dark";
    document.body.classList.toggle("light", th==="light");
  }

  // =========================
  // History + log
  // =========================
  function snapshot(){
    const s = structuredClone({...state});
    s.history = {undo:[], redo:[]};
    return s;
  }

  function logEvent(text){
    state.events.push({ t: now(), text: String(text).slice(0,260) });
    state.events = state.events.slice(-260);
  }

  function pushHistory(label){
    state.history.undo.push(snapshot());
    if(state.history.undo.length > MAX_HISTORY) state.history.undo.shift();
    state.history.redo = [];
    if(label) logEvent(label);
    save();
    updateUndoRedo();
  }

  function undo(){
    if(!state.history.undo.length) return;
    const prev = state.history.undo.pop();
    const cur = snapshot();
    state.history.redo.push(cur);
    const keep = state.history;
    state = {...prev, history: keep};
    applyTheme();
    save();
    renderAll();
  }

  function redo(){
    if(!state.history.redo.length) return;
    const next = state.history.redo.pop();
    const cur = snapshot();
    state.history.undo.push(cur);
    const keep = state.history;
    state = {...next, history: keep};
    applyTheme();
    save();
    renderAll();
  }

  function updateUndoRedo(){
    btnUndo.disabled = state.history.undo.length===0;
    btnRedo.disabled = state.history.redo.length===0;
  }

  // =========================
  // Parsing (tolerant)
  // =========================
  function cleanLine(s){
    let x = String(s||"").trim();
    x = x.replace(/[|¦]+/g," ").replace(/\s{2,}/g," ").trim();
    return x;
  }

  function isCategoryLine(line){
    const s = String(line||"").trim();
    if(!s) return false;
    if(/:\s*$/.test(s)) return true;
    if(/^[A-ZÀ-ÖØ-Ý0-9\s/]+$/.test(s) && s.length <= 40) return true;
    return false;
  }

  function parseEthorion(text){
    const t = text.toLowerCase();
    const m = t.match(/(\d{1,3})\s*(?:ethorion|ethorions|eth)\b/);
    if(m) return clamp(parseInt(m[1],10)||1, 1, 200);
    const m2 = t.match(/(\d{1,3})\s*(?:torion|torions)\b/);
    if(m2) return clamp(parseInt(m2[1],10)||1, 1, 200);
    return null;
  }

  function parseMinutes(text){
    const t = text.toLowerCase();
    const m = t.match(/(\d{1,3})\s*(?:minutes|minute|min)\b/);
    if(m) return clamp(parseInt(m[1],10)||0, 1, 999);
    return null;
  }

  function parseImportance(text){
    const t = text.toLowerCase();
    const m = t.match(/\b(?:importance|prio|priorité)\s*(\d)\b/);
    if(m) return clamp(parseInt(m[1],10)||2, 1, 3);
    return null;
  }

  function removeMetaFromTitle(raw){
    let x = raw.replace(/\s*[—–]\s*/g, " — ");
    x = x.replace(/\b\d+\s*(ethorion|ethorions|eth|torion|torions)\b/gi, "");
    x = x.replace(/\b\d+\s*(minutes|minute|min)\b/gi, "");
    x = x.replace(/\b(importance|prio|priorité)\s*\d\b/gi, "");
    x = x.replace(/\b(fait|done)\b/gi, "");
    x = x.replace(/\s{2,}/g," ").trim();
    const parts = x.split("—").map(s=>s.trim()).filter(Boolean);
    return (parts[0] || x).trim();
  }

  function inferEnergyFromText(title, category){
    const t = (title+" "+(category||"")).toLowerCase();
    if(/\b(appeler|tél|tel|téléphone|mail|email|répondre|encoder|encodage|note)\b/.test(t)) return 1;
    if(/\b(rapport|rédaction|dossier|analyse|attestation|procédure)\b/.test(t)) return 3;
    return 2;
  }

  function defaultEthFromEnergyHint(line, cat){
    const t = (line+" "+(cat||"")).toLowerCase();
    if(/\b(appeler|tél|tel|téléphone|répondre|mail|email)\b/.test(t)) return 2;
    if(/\b(rapport|dossier|attestation)\b/.test(t)) return 10;
    return 3;
  }

  function parsePasted(raw){
    const lines = String(raw||"").split(/\r?\n/).map(cleanLine).filter(Boolean);
    let currentCategory = "Sans catégorie";
    const out = [];

    for(const line0 of lines){
      const line = line0.trim();
      if(!line) continue;

      if(isCategoryLine(line)){
        currentCategory = line.replace(/:+$/,"").trim() || currentCategory;
        continue;
      }

      const eth = parseEthorion(line) ?? defaultEthFromEnergyHint(line, currentCategory);
      const minutes = parseMinutes(line);
      const prio = parseImportance(line) ?? 2;
      const title = cleanLine(removeMetaFromTitle(line));
      if(!title) continue;

      out.push({
        title,
        category: currentCategory,
        ethorionTotal: eth,
        ethorionRemaining: eth,
        minutesHint: minutes || null,
        priority: prio,
        energyTag: inferEnergyFromText(title, currentCategory)
      });
    }
    return out;
  }

  // =========================
  // Day baseline
  // =========================
  function ensureDay(){
    const today = isoDay();
    if(state.day.id !== today){
      state.day.id = today;
      state.day.startTasks = 0;
      state.day.startEth = 0;
      state.kiffance.lastWorkEth = 0;
    }
    if(state.day.startTasks===0 && state.day.startEth===0){
      setDayBaseline("Départ fixé");
    }
  }

  function setDayBaseline(label){
    const active = state.tasks.filter(t=>!t.done);
    state.day.startTasks = active.length;
    state.day.startEth = active.reduce((a,t)=>a + (t.ethorionRemaining||0), 0);
    logEvent(label || "Départ fixé");
    save();
  }

  // =========================
  // RESET (replaces "Nouveau jour")
  // =========================
  function resetAll(){
    if(!confirm("RESET = tout effacer (liste en cours + stats) ?")) return;
    pushHistory("RESET");
    const keepSets = state.sets;
    const keepTheme = state.ui?.theme || "dark";
    state = initial();
    state.sets = keepSets;
    state.ui.theme = keepTheme;
    applyTheme();
    save();
    renderAll();
    showToast("RESET. Tout est revenu à zéro.", 2200);
    floatSay("Terrain rasé. Plus rien. Même la culpabilité a déménagé.", 3600);
  }

  // =========================
  // Tasks helpers
  // =========================
  function nextOrder(){
    const act = state.tasks.filter(t=>!t.done);
    if(!act.length) return 1;
    return Math.max(...act.map(t=>t.order||0)) + 1;
  }

  function addTasksFromText(raw){
    const parsed = parsePasted(raw);
    if(!parsed.length){
      showToast("Rien à ajouter.", 1800);
      floatSay("Aucun ennemi détecté. Recolle la matière.");
      return;
    }
    pushHistory(`Ajout ${parsed.length} tâche(s)`);

    const start = nextOrder();
    parsed.forEach((p,i)=>{
      state.tasks.push({
        id: uid(),
        title: p.title,
        category: p.category,
        ethorionTotal: p.ethorionTotal,
        ethorionRemaining: p.ethorionRemaining,
        minutesHint: p.minutesHint,
        priority: p.priority,
        energyTag: p.energyTag,
        notes: "",
        done: false,
        order: start+i,
        boost: false,            // <- manual priority boost (works in roulette)
        isKiffance: false,       // <- kiffance tasks are special
        startedAt: null,         // <- real timing
        doneAt: null,
        createdAt: now()
      });
    });

    ensureDay();
    if(!state.focusId){
      const t = pickNext(true);
      if(t) state.focusId = t.id;
    }

    save();
    renderAll();
    showToast("Ajouté.", 1400);
    floatSay("Cibles chargées. Le boss final te regarde déjà.");
  }

  function getTask(id){ return state.tasks.find(t=>t.id===id) || null; }

  function markStarted(t){
    if(!t || t.done) return;
    if(!t.startedAt) t.startedAt = now();
  }

  function setFocus(id){
    state.focusId = id;
    const t = getTask(id);
    // Do NOT auto-start on focus: start when action begins (dego/done)
    save();
    renderFocus();
  }

  function finishTask(taskId, opts={}){
    const t = getTask(taskId);
    if(!t) return;

    if(!opts.silent) pushHistory("Terminer tâche");

    markStarted(t);
    t.done = true;
    t.doneAt = now();
    t.ethorionRemaining = 0;

    // Kiffance bookkeeping: completing a kiffance counts as "rest achieved"
    if(t.isKiffance){
      state.kiffance.lastWorkEth = 0;
    }

    const big = (t.ethorionTotal||0) >= 10;
    const epicChance = big ? 0.55 : 0.18;
    const epic = Math.random() < epicChance;

    // FX
    if(epic){
      confetti(2.8);
      boom(1200);
      playBoom(); // sound
      showToast(pick(DONE_EPIC), 3800);
      floatSay(pick(DONE_EPIC_POETIC), 4200);
    }else{
      confetti(1.4);
      flash();
      playBoom(); // sound
      showToast(pick(DONE_LINES), 2400);
      floatSay(pick(DONE_POETIC), 3000);
    }

    // Simple celebration overlay (no image, auto close)
    showCelebration(t, epic);

    const next = pickNext();
    state.focusId = next ? next.id : null;

    save();
    renderAll();

    if(!state.focusId && countActiveTasks()===0){
      setTimeout(()=>{
        confetti(3.4);
        boom(1800);
        playBoom();
        floatSay(pick(FINISH_ALL), 5200);
        showToast("MISSION TOTALE TERMINÉE.", 5200);
      }, 250);
    }
  }

  function degoOne(){
    const t = getTask(state.focusId);
    if(!t){
      showToast("CIBLE EN COURS DE RECHERCHE", 1600);
      floatSay("Radar en balayage…");
      return;
    }

    pushHistory("Dégommage");

    markStarted(t);
    t.ethorionRemaining = Math.max(0, (t.ethorionRemaining||0) - 1);

    // Work-eth counter feeds kiffance engine (only for non-kiffance)
    if(!t.isKiffance) state.kiffance.lastWorkEth = (state.kiffance.lastWorkEth||0) + 1;

    if(Math.random() < 0.38) confetti(0.9);
    flashSoft();
    floatSay(pick(LINES), 2600);

    if(t.ethorionRemaining===0){
      finishTask(t.id, {silent:true});
      return;
    }

    save();
    renderAll();
  }

  function skip(){
    const next = pickNext(true);
    state.focusId = next ? next.id : null;
    save();
    renderAll();
    showToast(next ? "CIBLE REPLACÉE." : "PLUS DE CIBLES.", 1600);
    floatSay(next ? "Changement de cible." : pick(FINISH_ALL), 2400);
  }

  function deleteTask(taskId){
    if(!confirm("Supprimer ?")) return;
    pushHistory("Supprimer tâche");
    if(state.focusId === taskId) state.focusId = null;
    state.tasks = state.tasks.filter(x=>x.id!==taskId);
    save();
    renderAll();
  }

  function duplicateTask(taskId){
    const t = getTask(taskId);
    if(!t) return;
    pushHistory("Dupliquer tâche");
    const c = structuredClone(t);
    c.id = uid();
    c.done = false;
    c.doneAt = null;
    c.startedAt = null;
    c.ethorionRemaining = c.ethorionTotal;
    c.order = nextOrder();
    c.createdAt = now();
    state.tasks.push(c);
    save();
    renderAll();
    showToast("Dupliqué.", 1400);
  }

  function setEthorion(taskId){
    const t = getTask(taskId);
    if(!t || t.done) return;
    const val = prompt("ETHORION total ?", String(t.ethorionTotal||3));
    if(val===null) return;

    pushHistory("Régler ethorion");
    const n = clamp(parseInt(val,10)||t.ethorionTotal||3, 1, 200);

    const wasTotal = Math.max(1, t.ethorionTotal||1);
    const wasRem = clamp(t.ethorionRemaining||0, 0, wasTotal);
    const ratio = wasTotal ? (wasRem/wasTotal) : 1;

    t.ethorionTotal = n;
    t.ethorionRemaining = clamp(Math.round(n*ratio), 0, n);
    if(t.ethorionRemaining===0) t.ethorionRemaining = Math.min(1,n);

    save();
    renderAll();
    showToast("OK", 1200);
  }

  function editTask(taskId){
    const t = getTask(taskId);
    if(!t || t.done) return;

    const title = prompt("Titre ?", t.title);
    if(title===null) return;

    const cat = prompt("Catégorie ?", t.category || "Sans catégorie");
    if(cat===null) return;

    const pr = prompt("Priorité (1-3) ?", String(t.priority||2));
    if(pr===null) return;

    pushHistory("Éditer tâche");
    t.title = cleanLine(title).slice(0,120) || t.title;
    t.category = cleanLine(cat).slice(0,60) || t.category;
    t.priority = clamp(parseInt(pr,10)||2, 1, 3);

    // Recompute energyTag lightly
    t.energyTag = inferEnergyFromText(t.title, t.category);

    save();
    renderAll();
    showToast("Modifié.", 1400);
  }

  function toggleBoost(taskId){
    const t = getTask(taskId);
    if(!t || t.done) return;
    pushHistory("Boost");
    t.boost = !t.boost;
    save();
    renderAll();
    showToast(t.boost ? "BOOST activé." : "BOOST retiré.", 1400);
  }

  // =========================
  // Kiffance engine
  // =========================
  function kiffanceEligible(){
    const k = state.kiffance;
    if(!k?.enabled) return false;
    const n = clamp(parseInt(k.afterEth,10)||6, 2, 40);
    return (k.lastWorkEth||0) >= n;
  }

  function createKiffanceTask(){
    const k = state.kiffance;
    const durations = [5,10,15,20];
    const d = durations[Math.floor(Math.random()*durations.length)];
    const pool = k.pools[String(d)] || ["respirer", "boire de l'eau", "regarder par la fenêtre"];
    const act = pool[Math.floor(Math.random()*pool.length)];
    return {
      id: "kiff_"+uid(),
      title: `Pause ${d} min — ${act}`,
      category: "Zone de la kiffance",
      ethorionTotal: 1,
      ethorionRemaining: 1,
      minutesHint: d,
      priority: 3,
      energyTag: 1,
      notes: "",
      done: false,
      order: nextOrder(),
      boost: false,
      isKiffance: true,
      startedAt: null,
      doneAt: null,
      createdAt: now()
    };
  }

  function maybeInjectKiffanceCandidate(){
    if(!kiffanceEligible()) return null;
    const k = state.kiffance;
    const chance = clamp(Number(k.chance)||0.55, 0, 1);
    if(Math.random() > chance) return null;
    // Provide a kiffance task as the "next pick" without forcing it into tasks list yet
    return createKiffanceTask();
  }

  // =========================
  // Pool + Mode picks
  // =========================
  function getActivePool(){
    const base = state.tasks.filter(t=>!t.done && (t.ethorionRemaining||0) > 0);
    const sel = state.mode?.includeCats || [];
    if(!sel.length) return base;
    const set = new Set(sel);
    return base.filter(t => set.has(t.category || "Sans catégorie"));
  }

  function pickOrderedTask(){
    const pool = getActivePool();
    if(!pool.length) return null;

    const by = state.mode?.orderBy || "prio";
    const arr = pool.slice();

    if(by === "alpha"){
      arr.sort((a,b)=> (a.title||"").localeCompare(b.title||"", "fr"));
    } else if(by === "chrono"){
      arr.sort((a,b)=> (a.createdAt||0) - (b.createdAt||0));
    } else if(by === "cat"){
      arr.sort((a,b)=> (a.category||"").localeCompare(b.category||"", "fr") || (a.title||"").localeCompare(b.title||"", "fr"));
    } else if(by === "eth"){
      arr.sort((a,b)=> (b.ethorionRemaining||0) - (a.ethorionRemaining||0));
    } else {
      arr.sort((a,b)=> (b.priority||2)-(a.priority||2) || (a.order||0)-(b.order||0));
    }

    return arr[0];
  }

  function pickNext(allowSame=false){
    // Kiffance surprise has priority when eligible, but doesn't break your "mode"
    const kCandidate = maybeInjectKiffanceCandidate();
    if(kCandidate) return kCandidate;

    if(state.mode?.pick === "order"){
      return pickOrderedTask();
    }
    return pickEnergyRoulette(allowSame);
  }

  // =========================
  // Energy-based Roulette (with BOOST + order influence)
  // =========================
  function energyCaps(level){
    if(level===1) return { softMax: 1, rareMax: 3, rareProb: 0.22, hardMaxProb: 0.03, hardMax: 999 };
    if(level===2) return { softMax: 4, rareMax: 8, rareProb: 0.25, hardMaxProb: 0.08, hardMax: 16 };
    return { softMax: 8, rareMax: 16, rareProb: 0.28, hardMaxProb: 0.18, hardMax: 999 };
  }

  function pickEnergyRoulette(allowSame=false){
    const pool0 = getActivePool();
    if(!pool0.length) return null;

    const E = clamp(state.energyProfile.level||2, 1, 3);
    const M = clamp(state.energyProfile.motivation||2, 1, 3);
    const caps = energyCaps(E);

    const pool = pool0.filter(t=>{
      const rem = Math.max(1, Math.ceil(t.ethorionRemaining||1));
      if(rem <= caps.softMax) return true;
      if(rem <= caps.rareMax) return Math.random() < caps.rareProb;
      if(rem <= caps.hardMax) return Math.random() < caps.hardMaxProb;
      return false;
    });

    const finalPool = pool.length ? pool : pool0;

    const weights = finalPool.map(t=>{
      const rem = Math.max(1, Math.ceil(t.ethorionRemaining||1));
      const pr = (t.priority===3? 3 : t.priority===2? 2 : 1);

      let fit = 1.0;
      if(E===1) fit *= (t.energyTag===1 ? 1.60 : t.energyTag===2 ? 0.95 : 0.55);
      else if(E===2) fit *= (t.energyTag===1 ? 1.12 : t.energyTag===2 ? 1.25 : 0.98);
      else fit *= (t.energyTag===3 ? 1.30 : 1.06);

      let mot = 1.0;
      if(M===1) mot *= (rem<=2 ? 1.55 : rem<=4 ? 1.10 : 0.70);
      else if(M===2) mot *= (rem<=3 ? 1.18 : 1.0);

      const total = Math.max(1, t.ethorionTotal||1);
      const doneFrac = (total - (t.ethorionRemaining||0)) / total;
      const progressBoost = 1.0 + (doneFrac * 0.25);

      const longPenalty = (E===1 && rem>3) ? 0.65 : (E===2 && rem>8) ? 0.80 : 1.0;

      // Manual BOOST makes it more likely even in roulette
      const boost = t.boost ? 4.2 : 1.0;

      // Manual order influences roulette slightly (higher in list => smaller order => higher weight)
      const ord = Math.max(1, t.order||1);
      const orderBias = 1.0 + (1 / ord) * 1.2;

      return Math.max(0.2, rem * pr * fit * mot * progressBoost * longPenalty * boost * orderBias);
    });

    let candidate = weightedPick(finalPool, weights);
    if(!allowSame && state.focusId && candidate && candidate.id === state.focusId && finalPool.length > 1){
      candidate = weightedPick(finalPool, weights);
    }
    return candidate;
  }

  function weightedPick(items, weights){
    const total = weights.reduce((a,b)=>a+b,0);
    let r = Math.random()*total;
    for(let i=0;i<items.length;i++){
      r -= weights[i];
      if(r<=0) return items[i];
    }
    return items[items.length-1];
  }

  // Roulette suspense
  let rouletteLock = false;
  function roulette(){
    if(rouletteLock) return;
    rouletteLock = true;
    btnRoulette.disabled = true;
    btnRoulette.classList.add("spinning");

    const suspense = 520 + Math.floor(Math.random()*260);

    setTimeout(()=>{
      const t = pickNext();
      if(t){
        // If kiffance candidate is not yet in tasks, inject it now so it appears in lists/reports
        if(t.isKiffance && !state.tasks.some(x=>x.id===t.id)){
          pushHistory("Kiffance");
          state.tasks.push(t);
          // reset work counter immediately when the break is drawn (prevents chained breaks)
          state.kiffance.lastWorkEth = 0;
        }
        state.focusId = t.id;
        floatSay("Cible verrouillée.");
        showToast("CIBLE VERROUILLÉE.", 1600);
      }else{
        state.focusId = null;
        showToast("PLUS DE CIBLES.", 1600);
        floatSay(pick(FINISH_ALL), 2600);
      }

      btnRoulette.disabled = false;
      btnRoulette.classList.remove("spinning");
      rouletteLock = false;

      save();
      renderAll();
    }, suspense);
  }

  // =========================
  // List sort + reorder
  // =========================
  function getActiveSorted(){
    const items = state.tasks.filter(t=>!t.done);
    const sort = state.ui.sort || "order";
    if(sort==="prio"){
      items.sort((a,b)=>(b.priority||2)-(a.priority||2) || (a.order||0)-(b.order||0));
    }else if(sort==="eth"){
      items.sort((a,b)=>(b.ethorionRemaining||0)-(a.ethorionRemaining||0) || (b.priority||2)-(a.priority||2));
    }else if(sort==="cat"){
      items.sort((a,b)=> (a.category||"").localeCompare(b.category||"", "fr") || (a.order||0)-(b.order||0));
    }else{
      items.sort((a,b)=>(a.order||0)-(b.order||0));
    }
    return items;
  }

  function applyOrderFromList(ids){
    let k = 1;
    ids.forEach(id=>{
      const t = getTask(id);
      if(t && !t.done) t.order = k++;
    });
  }

  // =========================
  // Rendering
  // =========================
  function sumActiveEth(){
    return state.tasks.reduce((a,t)=>a + (t.done?0:(t.ethorionRemaining||0)), 0);
  }
  function countActiveTasks(){ return state.tasks.filter(t=>!t.done).length; }
  function countDoneTasks(){ return state.tasks.filter(t=>t.done).length; }

  function renderCounters(){
    ensureDay();

    const leftTasks = countActiveTasks();
    const leftEth = sumActiveEth();
    const doneTasks = countDoneTasks();

    const startT = state.day.startTasks || leftTasks;
    const startE = state.day.startEth || leftEth;

    const elimEth = Math.max(0, startE - leftEth);

    startTasksEl.textContent  = String(startT);
    startTasks2El.textContent = String(startT);
    leftTasksEl.textContent   = String(leftTasks);
    startEthEl.textContent    = String(startE);
    leftEthEl.textContent     = String(leftEth);
    elimEthEl.textContent     = String(elimEth);
    doneTasksEl.textContent   = String(doneTasks);

    const denom = Math.max(1, startE);
    const pctLeft = clamp(Math.round((leftEth/denom)*100), 0, 100);
    gFill.style.width = `${pctLeft}%`;
    gLabel.textContent = `${pctLeft}%`;

    updateUndoRedo();
  }

  function renderFocus(){
    const t = getTask(state.focusId);

    focusMode.textContent = (state.mode?.pick === "order") ? "ordre" : "roulette";
    focusEnergy.textContent = energyLabel(state.energyProfile.level);

    if(!t){
      focusTitle.textContent = "CIBLE EN COURS DE RECHERCHE";
      focusMeta.textContent = "—";
      focusEth.textContent = "0";
      focusPrio.textContent = "—";

      tFill.style.width = "100%";
      tLabel.textContent = "100%";

      btnDego.disabled = true;
      btnNotes.disabled = true;
      btnDone.disabled = true;
      btnSkip.disabled = false;
      return;
    }

    focusTitle.textContent = t.title;

    const hintMin = t.minutesHint ? ` · ${t.minutesHint} min` : "";
    const cat = t.category || "Sans catégorie";
    const boost = t.boost ? " · BOOST" : "";
    focusMeta.textContent = `${cat} · P${t.priority}${hintMin}${boost}`;

    focusEth.textContent = `${t.ethorionRemaining}/${t.ethorionTotal}`;
    focusPrio.textContent = String(t.priority);

    const total = Math.max(1, t.ethorionTotal||1);
    const rem = clamp(t.ethorionRemaining||0, 0, total);
    const pctLeft = clamp(Math.round((rem/total)*100), 0, 100);
    tFill.style.width = `${pctLeft}%`;
    tLabel.textContent = `${pctLeft}%`;

    btnDego.disabled = false;
    btnNotes.disabled = false;
    btnDone.disabled = false;
  }

  function renderAll(){
    renderCounters();
    renderFocus();
    renderDrawer();
  }

  // =========================
  // Drawer Tabs + Content
  // =========================
  const TAB_DEFS = [
    { key:"inbox",   label:"Inbox" },
    { key:"liste",   label:"Liste" },
    { key:"cats",    label:"Cat" },
    { key:"sets",    label:"Sets" },
    { key:"mode",    label:"Mode" },
    { key:"energie", label:"Énergie" },
    { key:"notes",   label:"Notes" },
    { key:"hist",    label:"Hist" },
    { key:"rapport", label:"Rapport" },
    { key:"params",  label:"Param" }
  ];

  function setTab(key){
    state.ui.activeTab = key;
    save();
    renderDrawer();
  }

  function renderTabs(){
    tabs.innerHTML = "";
    TAB_DEFS.forEach(t=>{
      const b = document.createElement("button");
      b.className = "tab" + (state.ui.activeTab===t.key ? " active" : "");
      b.textContent = t.label;
      b.addEventListener("click", ()=> setTab(t.key));
      tabs.appendChild(b);
    });
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }

  function miniBarPct(rem, total){
    total = Math.max(1, total||1);
    rem = clamp(rem||0, 0, total);
    return clamp(Math.round((rem/total)*100), 0, 100);
  }

  function renderTaskRow(t, {draggable=false}={}){
    const row = document.createElement("div");
    row.className = "trow" + (t.isKiffance ? " kiffance" : "");
    row.dataset.id = t.id;

    const pct = miniBarPct(t.ethorionRemaining, t.ethorionTotal);
    const boostTxt = t.boost ? "BOOST" : "boost";

    row.innerHTML = `
      <div class="trowTop">
        <div style="min-width:0;">
          <div class="tname ${t.done ? "done":""}">${esc(t.title)}</div>
          <div class="tmini">
            <span>${esc(t.category||"Sans catégorie")}</span>
            <span>·</span>
            <span>P${esc(String(t.priority))}</span>
            <span>·</span>
            <span>ETH ${esc(String(t.ethorionRemaining))}/${esc(String(t.ethorionTotal))}</span>
            ${t.isKiffance ? `<span>·</span><span style="color:rgba(255,154,56,0.95);font-weight:900;">KIFFANCE</span>` : ""}
            ${t.boost ? `<span>·</span><span style="color:rgba(56,255,154,0.95);font-weight:900;">BOOST</span>` : ""}
          </div>
        </div>
        <div class="tacts">
          ${!t.done ? `<button class="btn topFx" data-a="focus">Focus</button>` : ""}
          ${!t.done ? `<button class="btn topFx" data-a="edit">Edit</button>` : ""}
          ${!t.done ? `<button class="btn topFx" data-a="boost">${boostTxt}</button>` : ""}
          ${!t.done ? `<button class="btn topFx" data-a="eth">Eth</button>` : ""}
          ${!t.done ? `<button class="btn topFx" data-a="dup">Dupl</button>` : ""}
          ${!t.done ? `<button class="btn topFx" data-a="ok">OK</button>` : ""}
          <button class="btn" data-a="x">X</button>
        </div>
      </div>
      <div class="sbarMiniWrap" aria-label="Progression">
        <div class="sbarMiniFill" style="width:${pct}%"></div>
      </div>
    `;

    row.querySelectorAll("[data-a]").forEach(btn=>{
      const a = btn.dataset.a;
      btn.addEventListener("click", ()=>{
        if(a==="focus"){ setFocus(t.id); renderAll(); }
        if(a==="edit"){ editTask(t.id); }
        if(a==="boost"){ toggleBoost(t.id); }
        if(a==="eth"){ setEthorion(t.id); }
        if(a==="dup"){ duplicateTask(t.id); }
        if(a==="ok"){ finishTask(t.id); }
        if(a==="x"){ deleteTask(t.id); }
      });
    });

    if(draggable && !t.done){
      row.draggable = true;
      row.style.cursor = "grab";
    }

    return row;
  }

  function renderDrawerInbox(){
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="cardTitle"><span>Inbox</span><span>Ctrl/⌘+Enter</span></div>
      <textarea id="inboxTA" placeholder="Colle une liste.
Lignes finissant par : = catégories.
Tout le reste = tâches."></textarea>
      <div class="rowBtns">
        <button class="btn topFx" id="btnAdd">Ajouter</button>
        <button class="btn topFx" id="btnBaseline">Fixer départ</button>
      </div>
    `;
    const ta = card.querySelector("#inboxTA");
    const add = card.querySelector("#btnAdd");
    const baseline = card.querySelector("#btnBaseline");

    add.addEventListener("click", ()=>{
      addTasksFromText(ta.value);
      ta.value = "";
    });

    baseline.addEventListener("click", ()=>{
      pushHistory("Fixer départ");
      setDayBaseline("Départ re-fixé");
      renderAll();
      showToast("Départ fixé.", 1500);
      floatSay("Départ verrouillé. Exécution.");
    });

    ta.addEventListener("keydown", (e)=>{
      if((e.ctrlKey||e.metaKey) && e.key==="Enter"){
        e.preventDefault();
        add.click();
      }
    });

    return card;
  }

  function renderDrawerList(){
    const wrap = document.createElement("div");
    wrap.className = "card";
    wrap.innerHTML = `
      <div class="cardTitle">
        <span>Liste</span>
        <span>
          <select id="sortSel" aria-label="Tri">
            <option value="order">Tri: ordre</option>
            <option value="prio">Tri: priorité</option>
            <option value="eth">Tri: ethorion</option>
            <option value="cat">Tri: catégorie</option>
          </select>
        </span>
      </div>
      <div class="tmini">Astuce : réordonner ici influence aussi la roulette (un peu). Le bouton BOOST influence beaucoup.</div>
      <div class="list" id="taskList"></div>
      <details>
        <summary>Terminé</summary>
        <div class="inside">
          <div class="list" id="doneList"></div>
        </div>
      </details>
    `;

    const sortSel = wrap.querySelector("#sortSel");
    sortSel.value = state.ui.sort || "order";
    sortSel.addEventListener("change", ()=>{
      pushHistory("Tri");
      state.ui.sort = sortSel.value;
      save();
      renderDrawer();
    });

    const list = wrap.querySelector("#taskList");
    const items = getActiveSorted();

    // Draggable ALWAYS in list (even if sorted by prio/eth/cat) so you can promote tasks manually.
    const draggable = true;
    items.forEach(t=> list.appendChild(renderTaskRow(t, {draggable})));

    // Drag reorder updates t.order in the underlying state, regardless of current sort.
    let dragId = null;

    list.addEventListener("dragstart", (e)=>{
      const row = e.target.closest(".trow");
      if(!row) return;
      dragId = row.dataset.id;
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", dragId);
    });

    list.addEventListener("dragover", (e)=>{
      e.preventDefault();
      e.dataTransfer.dropEffect = "move";
    });

    list.addEventListener("drop", (e)=>{
      e.preventDefault();
      const targetRow = e.target.closest(".trow");
      if(!targetRow) return;

      const fromId = e.dataTransfer.getData("text/plain") || dragId;
      const toId = targetRow.dataset.id;
      if(!fromId || !toId || fromId===toId) return;

      const rows = [...list.querySelectorAll(".trow")];
      const fromEl = rows.find(r=>r.dataset.id===fromId);
      const toEl = rows.find(r=>r.dataset.id===toId);
      if(!fromEl || !toEl) return;

      pushHistory("Réordonner");

      const rect = toEl.getBoundingClientRect();
      const after = (e.clientY - rect.top) > rect.height/2;
      if(after) toEl.after(fromEl);
      else toEl.before(fromEl);

      const ids = [...list.querySelectorAll(".trow")].map(r=>r.dataset.id);
      applyOrderFromList(ids);

      save();
      renderDrawer();
      showToast("Ordre mis à jour.", 1400);
    });

    const doneList = wrap.querySelector("#doneList");
    state.tasks
      .filter(t=>t.done)
      .sort((a,b)=>(b.doneAt||0)-(a.doneAt||0))
      .slice(0, 60)
      .forEach(t=> doneList.appendChild(renderTaskRow(t)));

    return wrap;
  }

  function groupByCategory(tasks){
    const m = new Map();
    tasks.forEach(t=>{
      const k = t.category || "Sans catégorie";
      if(!m.has(k)) m.set(k, []);
      m.get(k).push(t);
    });
    const keys = [...m.keys()].sort((a,b)=>a.localeCompare(b, "fr"));
    return {m, keys};
  }

  function renderDrawerCats(){
    const wrap = document.createElement("div");
    wrap.className = "card";
    wrap.innerHTML = `<div class="cardTitle"><span>Catégories</span><span>pool actuel</span></div>`;

    const items = getActiveSorted();
    const {m, keys} = groupByCategory(items);

    keys.forEach(cat=>{
      const det = document.createElement("details");
      det.open = false;
      const sumEth = m.get(cat).reduce((a,t)=>a+(t.ethorionRemaining||0),0);
      const sum = document.createElement("summary");
      sum.textContent = `${cat} — ETH ${sumEth}`;
      det.appendChild(sum);

      const inside = document.createElement("div");
      inside.className = "inside";
      const list = document.createElement("div");
      list.className = "list";
      m.get(cat).forEach(t=> list.appendChild(renderTaskRow(t)));
      inside.appendChild(list);
      det.appendChild(inside);

      wrap.appendChild(det);
    });

    return wrap;
  }

  function renderDrawerSets(){
    const wrap = document.createElement("div");
    wrap.className = "card";
    wrap.innerHTML = `
      <div class="cardTitle"><span>Sets</span><span>appliquer = ajouter</span></div>
      <div class="list" id="setsList"></div>
      <div class="rowBtns">
        <button class="btn topFx" id="btnNewSet">+ Set</button>
      </div>
    `;

    const list = wrap.querySelector("#setsList");

    state.sets.forEach(s=>{
      const row = document.createElement("div");
      row.className = "trow";
      row.innerHTML = `
        <div class="trowTop">
          <div>
            <div class="tname">${esc(s.name)}</div>
            <div class="tmini">${esc(String((s.lines||[]).length))} lignes</div>
          </div>
          <div class="tacts">
            <button class="btn topFx" data-a="apply">Appliquer</button>
            <button class="btn topFx" data-a="edit">Éditer</button>
            <button class="btn" data-a="del">X</button>
          </div>
        </div>
      `;

      row.querySelector('[data-a="apply"]').addEventListener("click", ()=>{
        addTasksFromText((s.lines||[]).join("\n"));
        showToast("Set appliqué.", 1500);
        floatSay("Set injecté. Et maintenant… baston.");
      });

      row.querySelector('[data-a="edit"]').addEventListener("click", ()=>{
        openSetEditor(s.id);
      });

      row.querySelector('[data-a="del"]').addEventListener("click", ()=>{
        if(!confirm("Supprimer set ?")) return;
        pushHistory("Supprimer set");
        state.sets = state.sets.filter(x=>x.id!==s.id);
        save();
        renderDrawer();
      });

      list.appendChild(row);
    });

    wrap.querySelector("#btnNewSet").addEventListener("click", ()=> openSetEditor(null));
    return wrap;
  }

  function openSetEditor(setId){
    const s = setId ? state.sets.find(x=>x.id===setId) : null;

    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="cardTitle"><span>${s ? "Éditer set" : "Nouveau set"}</span><span>catégories avec :</span></div>
      <input type="text" id="setName" placeholder="Nom du set" value="${esc(s ? s.name : "")}">
      <textarea id="setLines" placeholder="CATÉGORIE:
Tâche — 3 ethorions — importance 2">${esc(s ? (s.lines||[]).join("\n") : "")}</textarea>
      <div class="rowBtns">
        <button class="btn topFx" id="btnSaveSet">Enregistrer</button>
        <button class="btn" id="btnCancelSet">Annuler</button>
      </div>
    `;

    const name = card.querySelector("#setName");
    const lines = card.querySelector("#setLines");
    const saveBtn = card.querySelector("#btnSaveSet");
    const cancelBtn = card.querySelector("#btnCancelSet");

    saveBtn.addEventListener("click", ()=>{
      const n = cleanLine(name.value).slice(0,60);
      const ls = String(lines.value||"").split(/\r?\n/).map(cleanLine).filter(Boolean);
      if(!n){ showToast("Nom ?", 1400); return; }
      if(!ls.length){ showToast("Lignes ?", 1400); return; }

      pushHistory("Enregistrer set");

      if(s){
        s.name = n;
        s.lines = ls;
      }else{
        state.sets.push({ id:"set_"+uid(), name:n, lines: ls });
      }
      save();
      renderDrawer();
      showToast("OK", 1200);
    });

    cancelBtn.addEventListener("click", ()=> renderDrawer());
    drawerBody.innerHTML = "";
    drawerBody.appendChild(card);
  }

  function renderDrawerMode(){
    const wrap = document.createElement("div");
    wrap.className = "card";

    const allCats = getAllCategories();
    const included = (state.mode.includeCats||[]);

    wrap.innerHTML = `
      <div class="cardTitle"><span>Mode</span><span>cibles actives</span></div>

      <select id="pickMode">
        <option value="roulette">Roulette</option>
        <option value="order">Ordre</option>
      </select>

      <select id="orderBy">
        <option value="prio">Ordre: priorité</option>
        <option value="alpha">Ordre: alphabétique</option>
        <option value="chrono">Ordre: chronologie</option>
        <option value="cat">Ordre: catégorie</option>
        <option value="eth">Ordre: ethorions restants</option>
      </select>

      <textarea id="catFilter" placeholder="Catégories incluses (une par ligne).
Vide = toutes."></textarea>

      <div class="rowBtns">
        <button class="btn topFx" id="btnApplyMode">Appliquer</button>
        <button class="btn topFx" id="btnAllCats">Toutes</button>
        <button class="btn topFx" id="btnOnlyCurrentCat">Cat de la cible</button>
      </div>

      <div class="tmini">
        Catégories connues : ${esc(allCats.join(" · ") || "—")}
      </div>
    `;

    const pickMode = wrap.querySelector("#pickMode");
    const orderBy  = wrap.querySelector("#orderBy");
    const catFilter= wrap.querySelector("#catFilter");

    pickMode.value = state.mode.pick || "roulette";
    orderBy.value  = state.mode.orderBy || "prio";
    catFilter.value = included.join("\n");

    wrap.querySelector("#btnApplyMode").addEventListener("click", ()=>{
      pushHistory("Mode sélection");
      state.mode.pick = pickMode.value;
      state.mode.orderBy = orderBy.value;

      const raw = String(catFilter.value||"").trim();
      state.mode.includeCats = raw
        ? raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean)
        : [];

      if(state.focusId){
        const f = getTask(state.focusId);
        if(f){
          const pool = getActivePool();
          if(!pool.some(x=>x.id===f.id)){
            const nx = pickNext(true);
            state.focusId = nx ? nx.id : null;
          }
        }
      }

      save();
      renderAll();
      showToast("Mode appliqué.", 1400);
      floatSay("Filtres verrouillés. L’ennemi n’a aucune chance.");
    });

    wrap.querySelector("#btnAllCats").addEventListener("click", ()=>{
      catFilter.value = "";
    });

    wrap.querySelector("#btnOnlyCurrentCat").addEventListener("click", ()=>{
      const t = getTask(state.focusId);
      if(!t){ showToast("Pas de cible.", 1400); return; }
      catFilter.value = (t.category || "Sans catégorie");
    });

    return wrap;
  }

  function renderDrawerEnergy(){
    const wrap = document.createElement("div");
    wrap.className = "card";
    wrap.innerHTML = `
      <div class="cardTitle"><span>Énergie</span><span>influence roulette</span></div>

      <select id="lvl">
        <option value="1">Énergie: basse</option>
        <option value="2">Énergie: moyenne</option>
        <option value="3">Énergie: haute</option>
      </select>

      <select id="mot">
        <option value="1">Motivation: basse</option>
        <option value="2">Motivation: moyenne</option>
        <option value="3">Motivation: haute</option>
      </select>

      <div class="tmini">
        Énergie basse = surtout tâches courtes (≤1), parfois 2–3.
        Énergie haute = tâches plus longues acceptées.
      </div>

      <div class="rowBtns">
        <button class="btn topFx" id="btnApply">Appliquer</button>
      </div>
    `;

    const lvl = wrap.querySelector("#lvl");
    const mot = wrap.querySelector("#mot");
    lvl.value = String(state.energyProfile.level||2);
    mot.value = String(state.energyProfile.motivation||2);

    wrap.querySelector("#btnApply").addEventListener("click", ()=>{
      pushHistory("Énergie réglée");
      state.energyProfile.level = parseInt(lvl.value,10);
      state.energyProfile.motivation = parseInt(mot.value,10);
      save();
      renderAll();
      showToast("OK", 1200);
      floatSay("Réacteur interne calibré. On va casser du dossier.");
    });

    return wrap;
  }

  function renderDrawerNotes(){
    const wrap = document.createElement("div");
    wrap.className = "card";
    wrap.innerHTML = `
      <div class="cardTitle"><span>Notes</span><span>persistantes</span></div>
      <textarea id="scratchTA" placeholder="Numéros, idées, micro-notes…">${esc(state.scratch||"")}</textarea>
      <div class="rowBtns">
        <button class="btn topFx" id="btnSaveScratch">Enregistrer</button>
        <button class="btn" id="btnClearScratch">Vider</button>
      </div>
    `;

    const ta = wrap.querySelector("#scratchTA");
    wrap.querySelector("#btnSaveScratch").addEventListener("click", ()=>{
      pushHistory("Notes sauvegardées");
      state.scratch = ta.value.slice(0, 20000);
      save();
      showToast("Notes ok.", 1200);
      floatSay("Mémoire scellée. Aucun témoin.");
    });

    wrap.querySelector("#btnClearScratch").addEventListener("click", ()=>{
      if(!confirm("Vider les notes ?")) return;
      pushHistory("Notes vidées");
      state.scratch = "";
      save();
      renderDrawer();
      showToast("Vidé.", 1200);
    });

    return wrap;
  }

  function renderDrawerHist(){
    const wrap = document.createElement("div");
    wrap.className = "card";
    wrap.innerHTML = `<div class="cardTitle"><span>Historique</span><span>visible</span></div>`;

    const list = document.createElement("div");
    list.className = "list";

    state.events.slice().reverse().slice(0, 160).forEach(ev=>{
      const row = document.createElement("div");
      row.className = "trow";
      const d = new Date(ev.t);
      const ts = `${String(d.getHours()).padStart(2,"0")}:${String(d.getMinutes()).padStart(2,"0")}`;
      row.innerHTML = `<div class="tmini"><b>${esc(ts)}</b> · ${esc(ev.text)}</div>`;
      list.appendChild(row);
    });

    wrap.appendChild(list);
    return wrap;
  }

  // RAPPORT: ONLY completed tasks + real time spent
  function renderDrawerRapport(){
    const wrap = document.createElement("div");
    wrap.className = "card";
    wrap.innerHTML = `<div class="cardTitle"><span>Rapport</span><span>terminé</span></div>`;

    const today = isoDay();
    const doneToday = state.tasks
      .filter(t=>t.done && t.doneAt && isoDay(new Date(t.doneAt))===today)
      .sort((a,b)=>(b.doneAt||0)-(a.doneAt||0));

    const list = document.createElement("div");
    list.className = "list";

    let totalMs = 0;

    if(!doneToday.length){
      const row = document.createElement("div");
      row.className = "trow";
      row.innerHTML = `<div class="tname">Rien de terminé aujourd’hui</div><div class="tmini">Ce n’est pas un jugement moral. C’est un constat cosmique.</div>`;
      wrap.appendChild(row);
      return wrap;
    }

    doneToday.forEach(t=>{
      const s = t.startedAt || t.doneAt;
      const e = t.doneAt;
      const dur = Math.max(0, (e||0) - (s||0));
      totalMs += dur;

      const mins = Math.round(dur/60000);
      const row = document.createElement("div");
      row.className = "trow" + (t.isKiffance ? " kiffance" : "");
      row.innerHTML = `
        <div class="tname">${esc(t.title)}</div>
        <div class="tmini">${esc(t.category||"Sans catégorie")} · ${t.isKiffance ? "pause" : "travail"} · ${esc(String(mins))} min</div>
      `;
      list.appendChild(row);
    });

    const totalMin = Math.round(totalMs/60000);
    const head = document.createElement("div");
    head.className = "trow";
    head.innerHTML = `
      <div class="tname">Aujourd’hui : terminé</div>
      <div class="tmini">${esc(String(doneToday.length))} tâche(s) · Temps total mesuré : ${esc(String(totalMin))} min</div>
    `;

    wrap.appendChild(head);
    wrap.appendChild(list);
    return wrap;
  }

  // PARAMS: light mode + kiffance settings
  function renderDrawerParams(){
    const wrap = document.createElement("div");
    wrap.className = "card";

    const th = state.ui.theme || "dark";
    const k = state.kiffance;

    wrap.innerHTML = `
      <div class="cardTitle"><span>Paramètres</span><span>affichage</span></div>

      <select id="themeSel">
        <option value="dark">Thème : sombre</option>
        <option value="light">Thème : clair</option>
      </select>

      <details>
        <summary>Zone de la kiffance</summary>
        <div class="inside">
          <select id="kOn">
            <option value="1">Kiffance : ON</option>
            <option value="0">Kiffance : OFF</option>
          </select>

          <input type="number" id="kAfter" min="2" max="40" step="1" placeholder="Après combien d’ETH de travail ?">

          <input type="number" id="kChance" min="0" max="1" step="0.05" placeholder="Chance (0..1)">

          <div class="tmini">
            Fonctionnement : après X ETH de travail, la roulette peut proposer une pause surprise.
            Objectif : endurance mentale, pas héroïsme inutile.
          </div>

          <div class="rowBtns">
            <button class="btn topFx" id="btnSaveParams">Enregistrer</button>
          </div>
        </div>
      </details>
    `;

    const themeSel = wrap.querySelector("#themeSel");
    themeSel.value = th;
    themeSel.addEventListener("change", ()=>{
      pushHistory("Thème");
      state.ui.theme = themeSel.value;
      applyTheme();
      save();
      showToast("Thème appliqué.", 1200);
    });

    const kOn = wrap.querySelector("#kOn");
    const kAfter = wrap.querySelector("#kAfter");
    const kChance = wrap.querySelector("#kChance");
    kOn.value = k.enabled ? "1" : "0";
    kAfter.value = String(k.afterEth ?? 6);
    kChance.value = String(k.chance ?? 0.55);

    wrap.querySelector("#btnSaveParams").addEventListener("click", ()=>{
      pushHistory("Paramètres");
      state.kiffance.enabled = (kOn.value==="1");
      state.kiffance.afterEth = clamp(parseInt(kAfter.value,10)||6, 2, 40);
      state.kiffance.chance = clamp(Number(kChance.value)||0.55, 0, 1);
      save();
      showToast("Paramètres enregistrés.", 1400);
      floatSay("Réglages validés. Le cerveau respire. Le backlog pleure.");
    });

    return wrap;
  }

  function renderDrawer(){
    renderTabs();
    drawerBody.innerHTML = "";

    const tab = state.ui.activeTab || "inbox";
    if(tab==="inbox") drawerBody.appendChild(renderDrawerInbox());
    else if(tab==="liste") drawerBody.appendChild(renderDrawerList());
    else if(tab==="cats") drawerBody.appendChild(renderDrawerCats());
    else if(tab==="sets") drawerBody.appendChild(renderDrawerSets());
    else if(tab==="mode") drawerBody.appendChild(renderDrawerMode());
    else if(tab==="energie") drawerBody.appendChild(renderDrawerEnergy());
    else if(tab==="notes") drawerBody.appendChild(renderDrawerNotes());
    else if(tab==="hist") drawerBody.appendChild(renderDrawerHist());
    else if(tab==="rapport") drawerBody.appendChild(renderDrawerRapport());
    else if(tab==="params") drawerBody.appendChild(renderDrawerParams());
    else drawerBody.appendChild(renderDrawerInbox());
  }

  // =========================
  // Notes for current task (quick)
  // =========================
  function openNotes(){
    const t = getTask(state.focusId);
    if(!t){
      showToast("Pas de cible.", 1400);
      floatSay("Aucune cible à annoter.");
      return;
    }

    openDrawer();
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="cardTitle"><span>Notes (cible)</span><span>${esc(t.title).slice(0,18)}…</span></div>
      <textarea id="notesTA" placeholder="Notes">${esc(t.notes||"")}</textarea>
      <div class="rowBtns">
        <button class="btn topFx" id="btnSaveNotes">Enregistrer</button>
        <button class="btn" id="btnBack">Retour</button>
      </div>
    `;
    const ta = card.querySelector("#notesTA");
    card.querySelector("#btnSaveNotes").addEventListener("click", ()=>{
      pushHistory("Note enregistrée");
      t.notes = ta.value.slice(0, 12000);
      save();
      renderAll();
      showToast("Note ok.", 1200);
      floatSay("Trace conservée. Comme un film d’action, mais administratif.");
    });
    card.querySelector("#btnBack").addEventListener("click", ()=>{
      renderDrawer();
    });

    drawerBody.innerHTML = "";
    drawerBody.appendChild(card);
  }

  // =========================
  // Drawer open/close
  // =========================
  function openDrawer(){
    overlay.classList.add("show");
    drawer.classList.add("show");
    renderDrawer();
  }
  function closeDrawer(){
    overlay.classList.remove("show");
    drawer.classList.remove("show");
  }

  btnMenu.addEventListener("click", openDrawer);
  btnMiniMenu.addEventListener("click", openDrawer);
  btnClose.addEventListener("click", closeDrawer);
  overlay.addEventListener("click", closeDrawer);

  // =========================
  // Buttons wiring
  // =========================
  btnReset.addEventListener("click", resetAll);
  btnRoulette.addEventListener("click", roulette);
  btnDego.addEventListener("click", degoOne);
  btnNotes.addEventListener("click", openNotes);
  btnDone.addEventListener("click", ()=>{
    const t = getTask(state.focusId);
    if(t) finishTask(t.id);
  });
  btnSkip.addEventListener("click", skip);

  btnUndo.addEventListener("click", undo);
  btnRedo.addEventListener("click", redo);

  // Keyboard
  window.addEventListener("keydown", (e)=>{
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    const inField = (tag==="textarea" || tag==="input" || tag==="select");

    if(e.key==="Escape"){
      closeDrawer();
      hideCelebration();
      return;
    }
    if(inField) return;

    if(e.key.toLowerCase()==="r"){ e.preventDefault(); roulette(); return; }
    if(e.key.toLowerCase()==="d"){ e.preventDefault(); degoOne(); return; }
    if(e.key.toLowerCase()==="m"){
      e.preventDefault();
      openDrawer();
      return;
    }

    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==="z" && !e.shiftKey){
      e.preventDefault(); undo(); return;
    }
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==="z" && e.shiftKey){
      e.preventDefault(); redo(); return;
    }
  });

  // =========================
  // Toast + Float + FX
  // =========================
  function showToast(msg, ms=1600){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove("show"), ms);
  }

  function floatSay(msg, ms=3200){
    floatLine.textContent = msg;
    floatLine.classList.add("show");
    clearTimeout(floatSay._t);
    floatSay._t = setTimeout(()=>floatLine.classList.remove("show"), ms);
  }

  function resizeFx(){
    fxCanvas.width = window.innerWidth * devicePixelRatio;
    fxCanvas.height = window.innerHeight * devicePixelRatio;
    fx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener("resize", resizeFx);
  resizeFx();

  function confetti(strength=1){
    const W = window.innerWidth, H = window.innerHeight;
    const cx = W/2, cy = H*0.62;
    const n = Math.floor(70*strength);
    const parts = [];
    for(let i=0;i<n;i++){
      const a = -Math.PI/2 + (Math.random()-0.5)*1.6;
      const sp = (3 + Math.random()*8)*strength;
      parts.push({ x:cx, y:cy, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: 55+Math.random()*45, r: 1+Math.random()*3 });
    }
    let f=0;
    const tick=()=>{
      f++;
      fx.clearRect(0,0,W,H);
      fx.fillStyle="rgba(230,230,230,0.88)";
      for(const p of parts){
        p.x += p.vx; p.y += p.vy;
        p.vy += 0.14;
        p.life -= 1;
        fx.globalAlpha = Math.max(0, p.life/100);
        fx.beginPath();
        fx.arc(p.x,p.y,p.r,0,Math.PI*2);
        fx.fill();
      }
      if(f<92) requestAnimationFrame(tick);
      else fx.clearRect(0,0,W,H);
    };
    requestAnimationFrame(tick);
  }

  function flash(){
    const div = document.createElement("div");
    div.style.position="fixed";
    div.style.inset="0";
    div.style.background="rgba(56,255,154,0.09)";
    div.style.pointerEvents="none";
    div.style.zIndex="115";
    div.style.opacity="0";
    div.style.transition="opacity 120ms ease";
    document.body.appendChild(div);
    requestAnimationFrame(()=> div.style.opacity="1");
    setTimeout(()=> div.style.opacity="0", 160);
    setTimeout(()=> div.remove(), 420);
  }

  function flashSoft(){
    const div = document.createElement("div");
    div.style.position="fixed";
    div.style.inset="0";
    div.style.background="rgba(56,255,154,0.06)";
    div.style.pointerEvents="none";
    div.style.zIndex="115";
    div.style.opacity="0";
    div.style.transition="opacity 140ms ease";
    document.body.appendChild(div);
    requestAnimationFrame(()=> div.style.opacity="1");
    setTimeout(()=> div.style.opacity="0", 190);
    setTimeout(()=> div.remove(), 520);
  }

  function boom(ms=1200){
    const W = window.innerWidth, H = window.innerHeight;
    const cx = W/2, cy = H*0.60;
    const start = now();
    const dur = ms;

    const tick=()=>{
      const t = (now()-start)/dur;
      fx.clearRect(0,0,W,H);
      const k = Math.min(1, Math.max(0,t));
      const r = 20 + k*Math.max(W,H)*0.55;

      fx.globalAlpha = (1-k)*0.55;
      fx.strokeStyle = "rgba(56,255,154,0.75)";
      fx.lineWidth = 2 + (1-k)*6;
      fx.beginPath();
      fx.arc(cx,cy,r,0,Math.PI*2);
      fx.stroke();

      fx.globalAlpha = (1-k)*0.18;
      fx.fillStyle = "rgba(56,255,154,0.25)";
      fx.beginPath();
      fx.arc(cx,cy,r*0.55,0,Math.PI*2);
      fx.fill();

      if(t<1) requestAnimationFrame(tick);
      else fx.clearRect(0,0,W,H);
    };
    requestAnimationFrame(tick);
  }

  // =========================
  // SOUND: "boom / coup de feu-bombe" without external file
  // =========================
  let audioCtx = null;
  function ensureAudio(){
    if(audioCtx) return audioCtx;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if(!Ctx) return null;
    audioCtx = new Ctx();
    return audioCtx;
  }

  function playBoom(){
    const ctx = ensureAudio();
    if(!ctx) return;

    // Some browsers block audio until first user gesture:
    if(ctx.state === "suspended") ctx.resume().catch(()=>{});

    const t0 = ctx.currentTime;

    // Noise burst
    const bufferSize = ctx.sampleRate * 0.18;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<bufferSize;i++){
      // fast-decaying noise
      const x = (Math.random()*2-1);
      data[i] = x * Math.pow(1 - i/bufferSize, 3);
    }
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(900, t0);
    bp.Q.setValueAtTime(0.9, t0);

    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(1200, t0);

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(0.55, t0 + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.18);

    // Low thump (sub)
    const osc = ctx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(120, t0);
    osc.frequency.exponentialRampToValueAtTime(55, t0 + 0.12);

    const g2 = ctx.createGain();
    g2.gain.setValueAtTime(0.0001, t0);
    g2.gain.exponentialRampToValueAtTime(0.35, t0 + 0.01);
    g2.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.18);

    noise.connect(bp);
    bp.connect(lp);
    lp.connect(gain);
    gain.connect(ctx.destination);

    osc.connect(g2);
    g2.connect(ctx.destination);

    noise.start(t0);
    osc.start(t0);
    noise.stop(t0 + 0.19);
    osc.stop(t0 + 0.19);
  }

  // =========================
  // Celebration overlay (simple, auto close)
  // =========================
  const CELE_LINES = [
    "Le dossier vient de se faire expulser du multivers.",
    "Tu viens de gagner une bataille contre une feuille A4 invisible.",
    "La réalité vient de cligner des yeux. Tu as frappé au bon endroit.",
    "L’obstacle s’est évaporé. Personne ne sait pourquoi. Tant mieux.",
    "L’administration a perdu. C’est rare. Savoure.",
    "Tu viens d’arracher un bout de chaos avec les dents. Classe."
  ];
  const CELE_SUBS = [
    "L’univers valide ton geste. Sans papier à signer.",
    "Ce résultat est officiellement non remboursable mais satisfaisant.",
    "Le backlog recule comme un chat vexé.",
    "Une légende dit que tu continues. On va vérifier.",
    "Ton cerveau vient de gagner 3 points de dignité."
  ];

  function showCelebration(task, epic){
    celeTitle.textContent = epic ? "Victoire majeure" : "Victoire";
    celeMain.textContent = pick(CELE_LINES);
    celeSub.textContent = task.isKiffance ? "Pause validée. Recharge installée." : pick(CELE_SUBS);

    celeOverlay.classList.add("show");
    clearTimeout(showCelebration._t);
    showCelebration._t = setTimeout(()=>hideCelebration(), 1850);
  }

  function hideCelebration(){
    celeOverlay.classList.remove("show");
  }
  celeOverlay.addEventListener("click", ()=>hideCelebration()); // optional: click also closes, but auto-close already

  // =========================
  // Labels + helpers
  // =========================
  function energyLabel(v){
    return (v===1 ? "basse" : v===2 ? "moyenne" : "haute");
  }

  function getAllCategories(){
    const set = new Set();
    state.tasks.forEach(t=> set.add(t.category || "Sans catégorie"));
    return [...set].sort((a,b)=>a.localeCompare(b,"fr"));
  }

  // =========================
  // Copy lines (absurde, mais utile)
  // =========================
  const LINES = [
    "Un fragment de moins. Silence.",
    "Coup net. Respire.",
    "Ça tombe. Continue.",
    "Propre. Efficace.",
    "Un pas. Puis un autre.",
    "Tu viens de gifler l’entropie.",
    "Le chaos recule. Il râle un peu.",
    "Le dossier a cligné des yeux. Mauvaise idée."
  ];

  const DONE_POETIC = [
    "Cible dissoute. Place à la suivante.",
    "Fin propre. La charge baisse.",
    "On avance. Sans bruit.",
    "Un dossier de moins dans l’ombre.",
    "Tu viens de gagner un round contre la flemme.",
    "La paperasse vient de perdre un bras."
  ];

  const DONE_LINES = [
    "CIBLE EXTERMINÉE.",
    "TERMINÉ.",
    "ÉLIMINATION CONFIRMÉE.",
    "MISSION FINIE.",
    "KO. AU SUIVANT.",
    "VICTOIRE. SANS APPEL."
  ];

  const DONE_EPIC = [
    "DÉGOMMAGE MAJEUR.",
    "CIBLE ANNIHILÉE.",
    "EXTERMINATION TOTALE.",
    "DOSSIER RÉDUIT EN POUSSIÈRE.",
    "FINISHER. L’OBSTACLE EST AU SOL.",
    "ULTRA-KO ADMINISTRATIF."
  ];

  const DONE_EPIC_POETIC = [
    "Ça s’est effondré. Toi, tu restes debout.",
    "La montagne a bougé. Tu l’as faite céder.",
    "Même l’inertie cligne des yeux.",
    "Les trompettes jouent. Personne ne sait d’où elles viennent."
  ];

  const FINISH_ALL = [
    "Plus rien à dégommer. Tu es officiellement un ninja administratif.",
    "Mission complète. Champ de bataille nettoyé.",
    "Silence. Tout est tombé.",
    "Tu as vaincu. Le backlog demande un avocat."
  ];

  function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  // =========================
  // Init
  // =========================
  function init(){
    ensureDay();
    applyTheme();

    if(state.focusId && !getTask(state.focusId)) state.focusId = null;
    if(!state.focusId){
      const t = pickNext(true);
      if(t){
        // if kiffance pick at init, inject it
        if(t.isKiffance && !state.tasks.some(x=>x.id===t.id)){
          state.tasks.push(t);
          state.kiffance.lastWorkEth = 0;
        }
        state.focusId = t.id;
      } else {
        state.focusId = null;
      }
    }

    save();
    renderAll();
    floatSay("Prête. Ouvre le menu. Choisis ta baston.");
  }

  init();

})();
</script>
</body>
</html>
